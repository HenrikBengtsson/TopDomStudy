% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/overlap_score_summary_grid.R
\name{overlap_score_summary_grid}
\alias{overlap_score_summary_grid}
\title{Calculate and Summarize TopDom Overlap Scores Across Chromosomes, Bin Sizes, and Fractions}
\usage{
overlap_score_summary_grid(
  dataset,
  chromosomes,
  bin_sizes,
  rhos,
  window_size = 5L,
  nsamples = 50L,
  weights = c("by_length", "uniform"),
  domain_length = NULL,
  verbose = FALSE
)
}
\arguments{
\item{dataset}{(character string) The name of the data set.}

\item{chromosomes}{(character vector) Chromosomes to process.}

\item{bin_sizes}{(numeric vector) The set of bin sizes (in bps) to process.}

\item{rhos}{(numeric vector) The set of fractions (in (0,0.5]) to process.}

\item{window_size}{(integer) The TopDom windows size.
Argument passed as \code{window.size} to \code{\link[TopDom:TopDom]{TopDom::TopDom()}}.}

\item{nsamples}{(integer) Number of random samples for produce.}

\item{weights}{(character string) A character string specifying how overlap
scores across domains should be weighted.
Argument passed as is to \code{\link[=overlap_score_summary]{overlap_score_summary()}}.}

\item{domain_length}{(optional; character string or numeric vector of length two)
If specified, controls how to filter out too short or too long TopDom domains.
Argument passed as is to \code{\link[=overlap_score_summary]{overlap_score_summary()}}.}

\item{verbose}{(logical) If \code{TRUE}, verbose output is produced.}
}
\value{
A three-dimensional character array of pathname names where the first
dimension specify \code{chromosomes}, the second \code{bin_sizes}, and the third \code{rhos} (fractions).
}
\description{
Calculate and Summarize TopDom Overlap Scores Across Chromosomes, Bin Sizes, and Fractions
}
\section{Parallel processing}{

The \pkg{future} framework is used to parallelize in three layers:
\enumerate{
\item across (chromosome, bin size, fraction)
\item \code{\link[=overlap_scores_partitions]{overlap_scores_partitions()}}:
\enumerate{
\item across a single chromosome (already subsetted above)
\item across \code{nsamples} random samples
}
}

An example of a \code{\link[future:plan]{future::plan()}} setup for parallelization on the
local machine is:\if{html}{\out{<div class="r">}}\preformatted{ plan(list(
   chr_bin_rho = sequential,   ## across (chr, bin_size, rho)
   mono_chr    = sequential,   ## always a single chromosome
   samples     = multiprocess  ## across 1:nsamples
 ))
}\if{html}{\out{</div>}}

Another is,\if{html}{\out{<div class="r">}}\preformatted{ plan(list(
   chr_bin_rho = multiprocess, ## across (chr, bin_size, rho)
   mono_chr    = sequential,   ## always a single chromosome
   samples     = sequential    ## across 1:nsamples
 ))
}\if{html}{\out{</div>}}

For parallelization on a HPC cluster via a scheduler,\if{html}{\out{<div class="r">}}\preformatted{ hpc_scheduler <- tweak(future.batchtools::batchtools_torque,
                        resources = list(nodes="1:ppn=8", vmem="32gb"))
 plan(list(
   chr_bin_rho = hpc_scheduler,
   mono_chr    = sequential,
   samples     = multiprocess
 ))
}\if{html}{\out{</div>}}
}

